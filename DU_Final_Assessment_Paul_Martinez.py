"""
University of Denver – Office of Institutional Research & Analysis
Data Scientist Technical Assessment (Final)

Author: Paul Martinez
Environment: Python 3.13.x (IDLE, Windows)
Date: 2025-09-05

Purpose:
    This script fulfills the final assessment requirement to produce, via a single SQL query,
    a one-record-per-person dataset from the SQLite database built by `create_db.py`.
    The single SELECT query (no CREATE/INSERT, no temporary tables) may use subqueries and/or CTEs.
    The query:
      - Indicates census-level enrollment and persistence (per definitions in this script)
      - Computes a race/ethnicity column
      - Includes relevant curricular elements and program information
      - Computes GPA for each record
      - Includes minimum and maximum numerical grades for each record
      - Retrieves the most recent admission rating (by highest sequence); if none, imputes 'unk'
      - Includes any other clearly relevant data elements

Notes:
    - Dependencies: sqlite3, pandas
    - Input: SQLite database generated by `create_db.py` (paths handled in this script)
    - Output: pandas DataFrame containing the single-query result (optionally saved to file)
    - The script:
        1) Connects to the database
        2) Defines the single SQL query (as a string)
        3) Executes the query and returns the result as a pandas DataFrame
"""
######################################
######################################
######################################

# STEP 1 — Build local SQLite database (connect + create tables + ingest CSVs into student.db)

######################################
######################################
######################################

import pandas as pd
import sqlite3

def create_db():
    """
    Creates a local database, student.db, from csv files.
    Ensure that csv files are in directory from which script is executed.

    Args:
        none

    Returns:
        none
    """

    enr = pd.read_csv('fall_enrollment.csv', dtype={'id': str, 'term_code': str})
    grades = pd.read_csv('grades.csv')
    program = pd.read_csv('program_data.csv')
    ratings = pd.read_csv('admission_rating.csv', dtype={'id': str})

    conn = sqlite3.connect('student.db')
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS enr (
            id TEXT,
            term_code TEXT,
            census TEXT,
            race_desc TEXT,
            legal_sex_desc TEXT,
            ethn_desc TEXT,
            visa_desc TEXT,
            college TEXT,
            degr TEXT,
            majr TEXT,
            birth_date DATE)""")

    cursor.execute("""
            CREATE TABLE IF NOT EXISTS grades (
                id INTEGER,
                term_code INTEGER,
                final_course_grade TEXT)""")

    cursor.execute("""
                CREATE TABLE IF NOT EXISTS program (
                    COLLEGE TEXT,
                    DEGREE TEXT,
                    MAJOR TEXT,
                    PROGRAM TEXT)""")

    cursor.execute("""
                    CREATE TABLE IF NOT EXISTS ratings (
                        id TEXT,
                        admit_rating INTEGER,
                        sequence_no INTEGER)""")

    for df, table in zip(
            [enr, grades, program, ratings],
            ['enr', 'grades', 'program', 'ratings']):
        try:
            df.to_sql(table, conn, if_exists='replace', index=False)

        except Exception as e:
            print(e)

    cursor.close()
    conn.close()


if __name__ == '__main__':
    create_db()


######################################
######################################
######################################

# STEP 2 — Connect to Database

######################################
######################################
######################################

import sqlite3
from pathlib import Path

def connect_db(db_filename: str = "student.db") -> sqlite3.Connection:
    """
    Open a connection to the local SQLite database.

    Looks for the DB in the same folder as this script. If it doesn't exist,
    instructs the user to run STEP 1 to build it from CSVs.

    Returns:
        sqlite3.Connection
    """
    db_path = Path(__file__).with_name(db_filename)
    if not db_path.exists():
        raise FileNotFoundError(f"{db_path} not found. Run STEP 1 to build the database.")
    conn = sqlite3.connect(db_path)
    conn.row_factory = sqlite3.Row  # optional: access columns by name
    return conn

# Open a connection (to be reused in the next step)
conn = connect_db()


######################################
######################################
######################################

# STEP 2a — Verify connection (prints DB path and tables)

######################################
######################################
######################################

def verify_connection(conn, expected=("enr", "grades", "program", "ratings")) -> bool:
    """
    Confirms the SQLite connection is live and inspects available tables.
    Prints the database file path, the tables found, and any missing expected tables.
    Returns True if connected; False otherwise.
    """
    try:
        # Which DB file are we connected to?
        db_list = conn.execute("PRAGMA database_list").fetchall()
        db_file = None
        for row in db_list:
            # row: (seq, name, file)
            if (row[1] if not hasattr(row, "keys") else row["name"]) == "main":
                db_file = row[2] if not hasattr(row, "keys") else row["file"]
                break

        # What tables exist?
        rows = conn.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;").fetchall()
        tables = [r[0] if not hasattr(r, "keys") else r["name"] for r in rows]

        print(f"[OK] Connected to SQLite database: {db_file or 'student.db'}")
        print(f"[OK] Tables found: {tables or 'None'}")

        missing = [t for t in expected if t not in set(tables)]
        if missing:
            print(f"[WARN] Missing expected tables: {missing}")
        return True
    except Exception as e:
        print(f"[ERROR] Connection verification failed: {e}")
        return False

# Run the check
_ = verify_connection(conn)

######################################
######################################
######################################

# STEP 3 — Define the single SQL query (final, single SELECT — no temp tables)

######################################
######################################
######################################

SQL_SINGLE_QUERY = r"""
WITH
-- 1) Map letter grades to grade points, then aggregate by (id, term_code)
grades_mapped AS (
  SELECT
    CAST(id AS TEXT)      AS id,
    CAST(term_code AS TEXT) AS term_code,
    CASE TRIM(UPPER(final_course_grade))
      WHEN 'A'  THEN 4.0
      WHEN 'A-' THEN 3.7
      WHEN 'B+' THEN 3.3
      WHEN 'B'  THEN 3.0
      WHEN 'B-' THEN 2.7
      WHEN 'C+' THEN 2.3
      WHEN 'C'  THEN 2.0
      WHEN 'C-' THEN 1.7
      WHEN 'D+' THEN 1.3
      WHEN 'D'  THEN 1.0
      WHEN 'F'  THEN 0.0
      ELSE NULL
    END AS grade_points
  FROM grades
),
grades_term AS (
  SELECT
    id,
    term_code,
    AVG(grade_points)            AS term_gpa_raw,
    COUNT(grade_points)          AS course_count,
    MIN(grade_points)            AS min_grade_num,   
    MAX(grade_points)            AS max_grade_num    
  FROM grades_mapped
  WHERE grade_points IS NOT NULL
  GROUP BY id, term_code
),

-- 2) Split enr by census (WK3 vs EOT); collapse any duplicates per (id,term_code)
w3 AS (
  SELECT
    id, term_code,
    MAX(majr)            AS majr_w3,
    MAX(degr)            AS degr_w3,
    MAX(college)         AS college_w3,
    MAX(race_desc)       AS race_desc_w3,
    MAX(ethn_desc)       AS ethn_desc_w3,
    MAX(visa_desc)       AS visa_desc_w3,
    MAX(legal_sex_desc)  AS legal_sex_desc_w3,
    MAX(birth_date)      AS birth_date_w3
  FROM enr
  WHERE census = 'WK3'
  GROUP BY id, term_code
),
eot AS (
  SELECT
    id, term_code,
    MAX(majr)            AS majr_end,
    MAX(degr)            AS degr_end,
    MAX(college)         AS college_end,
    MAX(race_desc)       AS race_desc_end,
    MAX(ethn_desc)       AS ethn_desc_end,
    MAX(visa_desc)       AS visa_desc_end,
    MAX(legal_sex_desc)  AS legal_sex_desc_end,
    MAX(birth_date)      AS birth_date_end
  FROM enr
  WHERE census = 'EOT'
  GROUP BY id, term_code
),

-- 3) Program mapping (direct joins)
w3p AS (
  SELECT
    w3.*,
    p.PROGRAM AS program_w3
  FROM w3
  LEFT JOIN program AS p
    ON w3.college_w3 = p.COLLEGE
   AND w3.degr_w3    = p.DEGREE
   AND w3.majr_w3    = p.MAJOR
),
eotp AS (
  SELECT
    eot.*,
    p.PROGRAM AS program_end
  FROM eot
  LEFT JOIN program AS p
    ON eot.college_end = p.COLLEGE
   AND eot.degr_end    = p.DEGREE
   AND eot.majr_end    = p.MAJOR
),


-- 4) All (id, term_code) keys from either census point
keys AS (
  SELECT id, term_code FROM w3p
  UNION
  SELECT id, term_code FROM eotp
),

-- 5) Merge WK3 and EOT views
merged AS (
  SELECT
    k.id,
    k.term_code,
    w3p.majr_w3,  w3p.degr_w3,  w3p.college_w3,  w3p.program_w3,
    w3p.race_desc_w3, w3p.ethn_desc_w3, w3p.visa_desc_w3, w3p.legal_sex_desc_w3, w3p.birth_date_w3,
    eotp.majr_end, eotp.degr_end, eotp.college_end, eotp.program_end,
    eotp.race_desc_end, eotp.ethn_desc_end, eotp.visa_desc_end, eotp.legal_sex_desc_end, eotp.birth_date_end
  FROM keys k
  LEFT JOIN w3p  ON k.id = w3p.id  AND k.term_code = w3p.term_code
  LEFT JOIN eotp ON k.id = eotp.id AND k.term_code = eotp.term_code
),

-- 6) Enrollment flags, status transitions, preferred curriculum fields
logic AS (
  SELECT
    m.*,

    -- Enrollment at WK3/EOT (presence of any curriculum field)
    CASE WHEN (m.majr_w3  IS NOT NULL OR m.degr_w3  IS NOT NULL OR m.college_w3  IS NOT NULL) THEN 1 ELSE 0 END AS enrolled_w3,
    CASE WHEN (m.majr_end IS NOT NULL OR m.degr_end IS NOT NULL OR m.college_end IS NOT NULL) THEN 1 ELSE 0 END AS enrolled_eot,

    -- Persisted W3 -> EOT
    CASE
      WHEN (m.majr_w3 IS NOT NULL OR m.degr_w3 IS NOT NULL OR m.college_w3 IS NOT NULL)
       AND (m.majr_end IS NOT NULL OR m.degr_end IS NOT NULL OR m.college_end IS NOT NULL)
      THEN 1 ELSE 0
    END AS persisted_w3_to_end,

    -- Undeclared (UN*) at W3 -> not UN* at EOT (only for those who persisted)
    CASE
      WHEN ( (m.majr_w3 IS NOT NULL OR m.degr_w3 IS NOT NULL OR m.college_w3 IS NOT NULL)
         AND  (m.majr_end IS NOT NULL OR m.degr_end IS NOT NULL OR m.college_end IS NOT NULL)
         AND  (UPPER(m.majr_w3) GLOB 'UN*')
         AND  (m.majr_end IS NOT NULL AND UPPER(m.majr_end) NOT GLOB 'UN*') )
      THEN 1 ELSE 0
    END AS undeclared_to_declared,

    -- Preferred curriculum fields: use EOT if present, else W3
    CASE WHEN (m.majr_end  IS NOT NULL OR m.degr_end  IS NOT NULL OR m.college_end  IS NOT NULL) THEN m.college_end  ELSE m.college_w3 END AS college_pref,
    CASE WHEN (m.majr_end  IS NOT NULL OR m.degr_end  IS NOT NULL OR m.college_end  IS NOT NULL) THEN m.degr_end     ELSE m.degr_w3    END AS degree_pref,
    CASE WHEN (m.majr_end  IS NOT NULL OR m.degr_end  IS NOT NULL OR m.college_end  IS NOT NULL) THEN m.majr_end     ELSE m.majr_w3    END AS major_pref,
    CASE WHEN (m.majr_end  IS NOT NULL OR m.degr_end  IS NOT NULL OR m.college_end  IS NOT NULL) THEN m.program_end  ELSE m.program_w3 END AS program_pref,

    -- Gender: prefer EOT else W3
    COALESCE(m.legal_sex_desc_end, m.legal_sex_desc_w3) AS gender_pref,

    -- Raw fields for race/ethnicity logic (prefer W3, else EOT)
    COALESCE(NULLIF(m.visa_desc_w3,''),  NULLIF(m.visa_desc_end,''))  AS visa_raw,
    COALESCE(NULLIF(m.ethn_desc_w3,''),  NULLIF(m.ethn_desc_end,''))  AS ethn_raw,
    COALESCE(NULLIF(m.race_desc_w3,''),  NULLIF(m.race_desc_end,''))  AS race_raw
  FROM merged m
),


-- 7) Demographics: Race/Ethnicity (visa → ethnicity → race → Unknown) and Age at Term (MM/DD/YYYY)
race_eth_age AS (
  SELECT
    x.*,

    /* Race/Ethnicity */
    CASE
      WHEN (UPPER(COALESCE(NULLIF(x.visa_raw,''), '')) NOT IN ('', 'PR','RF','AS'))
        THEN 'International'
      WHEN LOWER(COALESCE(NULLIF(x.ethn_raw,''), '')) = 'hispanic or latino'
        THEN 'Hispanic or Latino'
      WHEN COALESCE(NULLIF(x.race_raw,''), '') <> ''
        THEN x.race_raw
      ELSE 'Unknown'
    END AS race_ethnicity,

    /* Age in whole years via day-count (as-of term anchor vs parsed birth date) */
    CAST( (julianday(x.asof_date) - julianday(date(
            printf('%04d-%02d-%02d', x.b_year, x.b_month, x.b_day)
         ))) / 365.25 AS INT ) AS age_years

  FROM (
    SELECT
      l.*,

      /* Term as-of date from term_code: 10/70→Oct 1, 20→Mar 1, 30/40/50→Jul 1; default Oct 1 */
      date(printf('%04d-%02d-01',
           CAST(substr(l.term_code,1,4) AS INT),
           CASE substr(l.term_code, length(l.term_code)-1, 2)
             WHEN '10' THEN 10 WHEN '70' THEN 10
             WHEN '20' THEN 3
             WHEN '30' THEN 7 WHEN '40' THEN 7 WHEN '50' THEN 7
             ELSE 10
           END
      )) AS asof_date,

      /* Coalesced birth_date (WK3 prioritized, else EOT), expected MM/DD/YYYY (single-digit ok) */
      COALESCE(l.birth_date_w3, l.birth_date_end) AS b,

      /* Parse month/day/year from MM/DD/YYYY (supports single-digit month/day) */
      CAST(substr(COALESCE(l.birth_date_w3, l.birth_date_end), 1,
                  instr(COALESCE(l.birth_date_w3, l.birth_date_end), '/') - 1) AS INT) AS b_month,

      CAST(substr(
             COALESCE(l.birth_date_w3, l.birth_date_end),
             instr(COALESCE(l.birth_date_w3, l.birth_date_end), '/') + 1,
             (instr(COALESCE(l.birth_date_w3, l.birth_date_end), '/') +
              instr(substr(COALESCE(l.birth_date_w3, l.birth_date_end),
                          instr(COALESCE(l.birth_date_w3, l.birth_date_end), '/') + 1), '/') ) -
              instr(COALESCE(l.birth_date_w3, l.birth_date_end), '/') - 1
           ) AS INT) AS b_day,

      CAST(substr(
             COALESCE(l.birth_date_w3, l.birth_date_end),
             (instr(COALESCE(l.birth_date_w3, l.birth_date_end), '/') +
              instr(substr(COALESCE(l.birth_date_w3, l.birth_date_end),
                          instr(COALESCE(l.birth_date_w3, l.birth_date_end), '/') + 1), '/') ) + 1
           ) AS INT) AS b_year

    FROM logic l
  ) AS x
),

-- 8) Most-recent admission rating per id (highest sequence_no)
ratings_latest AS (
  SELECT
    r.id,
    /* if multiple rows share the max sequence_no, pick the max admit_rating deterministically */
    MAX(CASE WHEN r.sequence_no = m.mx_seq THEN r.admit_rating END) AS admit_rating_latest
  FROM ratings r
  JOIN (
    SELECT id, MAX(sequence_no) AS mx_seq
    FROM ratings
    GROUP BY id
  ) AS m
    ON m.id = r.id
  GROUP BY r.id
)




-- Final SELECT: bring in GPA & course counts; pick requested columns
SELECT
  r.id,
  r.term_code,
  r.gender_pref                  AS gender,
  r.race_ethnicity,
  COALESCE(r.visa_raw, '') AS visa_type,
  r.age_years                    AS age,
  r.college_pref                 AS college,
  r.degree_pref                  AS degree,
  r.major_pref                   AS major,
  r.program_pref                 AS program,
  ROUND(gt.term_gpa_raw, 2)      AS term_gpa,
  ROUND(gt.min_grade_num, 2)     AS min_grade_num,   
  ROUND(gt.max_grade_num, 2)     AS max_grade_num, 
  gt.course_count,
  r.enrolled_w3,                 
  r.enrolled_eot,                
  r.persisted_w3_to_end,
  r.undeclared_to_declared,
  COALESCE(CAST(rl.admit_rating_latest AS TEXT), 'unk') AS admission_rating
  
FROM race_eth_age r
LEFT JOIN ratings_latest rl
  ON rl.id = r.id
LEFT JOIN grades_term gt
  ON gt.id = r.id AND gt.term_code = r.term_code
ORDER BY r.id, r.term_code
;
"""


######################################
######################################
######################################

# STEP 4 — Execute the query and return a pandas DataFrame

######################################
######################################
######################################

import pandas as pd

EXPECTED_COLUMNS = [
    "id",
    "term_code",
    "gender",
    "race_ethnicity",
    "age",
    "college",
    "degree",
    "major",
    "program",
    "term_gpa",
    "course_count",
    "persisted_w3_to_end",
    "undeclared_to_declared",
]

def execute_single_query(conn, sql=SQL_SINGLE_QUERY) -> pd.DataFrame:
    """
    Executes the single SELECT query and returns a pandas DataFrame.
    Also prints basic verification info (shape, columns).
    """
    df = pd.read_sql_query(sql, conn)

    # Basic verification
    print(f"[STEP 4] Query returned: {df.shape[0]:,} rows × {df.shape[1]} columns")
    cols = list(df.columns)
    print(f"[STEP 4] Columns: {cols}")

    missing = [c for c in EXPECTED_COLUMNS if c not in df.columns]
    if missing:
        print(f"[WARN] Missing expected columns: {missing}")
    else:
        print("[OK] All expected columns present.")

    # Preview
    print("[STEP 4] Head(5):")
    print(df.head(5))

    return df

# Run and (optionally) save
df_final = execute_single_query(conn, SQL_SINGLE_QUERY)

# Optional: save to CSV (toggle as needed)
SAVE_CSV = False
if SAVE_CSV:
    out_path = "single_query_output.csv"
    df_final.to_csv(out_path, index=False)
    print(f"[STEP 4] Saved to {out_path}")




